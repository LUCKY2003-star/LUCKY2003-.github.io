<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>浪漫粒子圣诞树</title>
    <style>
        * { margin: 0; padding: 0; }
        body { 
            min-height: 100vh; 
            background: #000; 
            overflow: hidden;
        }
        canvas { display: block; width: 100vw; height: 100vh; }
        .text {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-family: 'Arial';
            font-size: 20px;
            opacity: 0.8;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div class="text">Merry Christmas</div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        class Particle {
            constructor(x, y, size, color) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.color = color;
                this.speed = 0.05 + Math.random() * 0.1;
                this.vy = -this.speed;
                this.life = 300 + Math.random() * 100;
                this.remainingLife = this.life;
            }
            update() {
                this.y += this.vy;
                this.remainingLife--;
            }
            draw() {
                ctx.save();
                ctx.globalAlpha = this.remainingLife / this.life;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.restore();
            }
        }

        const particles = [];
        // 强制将圣诞树定位到屏幕中间（适配移动端）
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2; 
        const treeColor = 'rgba(255, 100, 150, 0.9)';
        const starColor = 'rgba(255, 255, 200, 1)';

        function createTree() {
            // 树顶星星
            for (let i = 0; i < 50; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 20;
                particles.push(new Particle(
                    centerX + Math.cos(angle) * radius,
                    centerY - 150 + Math.sin(angle) * radius,
                    2 + Math.random(),
                    starColor
                ));
            }

            // 树冠（缩小尺寸适配移动端）
            for (let layer = 0; layer < 8; layer++) {
                const layerHeight = 20;
                const layerWidth = 120 - layer * 12;
                const layerY = centerY - 150 + layer * layerHeight;
                for (let i = 0; i < layerWidth * 2; i++) {
                    const offsetX = (i - layerWidth / 2) * 1.2;
                    const randomOffset = Math.random() * 6 - 3;
                    particles.push(new Particle(
                        centerX + offsetX + randomOffset,
                        layerY + Math.random() * 8,
                        1.5 + Math.random(),
                        treeColor
                    ));
                }
            }
        }

        function drawReflection() {
            ctx.save();
            ctx.globalCompositeOperation = 'destination-over';
            ctx.scale(1, -1);
            ctx.translate(0, -canvas.height);
            ctx.globalAlpha = 0.3;
            particles.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, canvas.height - p.y + 150, p.size, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.fill();
            });
            ctx.restore();
        }

        function animate() {
            requestAnimationFrame(animate);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 强制生成足够粒子（打开即满屏）
            if (particles.length < 1000) createTree();

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update();
                p.draw();
                if (p.remainingLife <= 0) particles.splice(i, 1);
            }

            drawReflection();
        }

        // 初始化时直接生成满屏粒子
        for(let i=0; i<3; i++) createTree();
        animate();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>
